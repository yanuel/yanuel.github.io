<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title></title>
 <link href="" rel="self"/>
 <link href=""/>
 <updated>2017-03-30T18:33:38+08:00</updated>
 <id></id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>JAVA中「强引用，软引用，弱引用，虚引用」概念比较</title>
   <link href="/java/2016/03/15/JAVA%E4%B8%AD-%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8-%E6%A6%82%E5%BF%B5%E6%AF%94%E8%BE%83.html"/>
   <updated>2016-03-15T00:00:00+08:00</updated>
   <id>/java/2016/03/15/JAVA中「强引用，软引用，弱引用，虚引用」概念比较</id>
   <content type="html">&lt;p&gt;在JAVA垃圾回收，内存分配过程中，经常会涉及对象的生命周期，而判定对象是否存货都与“引用”有关。Java中的引用的定义非常简单粗糙：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就表示该内存块存在一个引用。这样分类会将对讲划分成两个类别：有引用、无引用。我们希望能够根据GC回收时间来对对象引用进行划分：当内存空间足够时，对象的引用继续保持；当内存不够时，抛弃这些对象。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;1-概念解释&quot;&gt;1. 概念解释&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;强引用&lt;/strong&gt;是使用最普遍的引用：Object o=new Object();  特点：不会被GC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;将对象的引用显示地置为null：o=null;     // 帮助垃圾收集器回收此对象&lt;/li&gt;
  &lt;li&gt;举例ArrayList的实现源代码：
  &lt;img src=&quot;http://sunxiaobiu.github.io/img/20160515P1.jpg&quot; alt=&quot;强引用 截图&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;软引用&lt;/strong&gt;用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;浏览器网页缓存实例：
 &lt;img src=&quot;http://sunxiaobiu.github.io/img/20160515P2.jpg&quot; alt=&quot;软引用 截图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;弱引用&lt;/strong&gt;与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
         如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;弱引用实例：
 &lt;img src=&quot;http://sunxiaobiu.github.io/img/20160515P3.jpg&quot; alt=&quot;弱引用 截图&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;虚引用&lt;/strong&gt;也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-对比不同&quot;&gt;2. 对比不同&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;引用类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;GC回收时间&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;用途&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;生存时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;强引用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;never&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对象的一般状态&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JVM停止运行时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;软引用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存不足时&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对象缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存不足时终止&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;弱引用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GC时&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对象缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GC后终止&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;虚引用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unknow&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unknow&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unknow&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>那些年踩过的坑——持续更新中...</title>
   <link href="/java/2016/02/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html"/>
   <updated>2016-02-22T00:00:00+08:00</updated>
   <id>/java/2016/02/22/那些年踩过的坑</id>
   <content type="html">&lt;p&gt;在JAVA web开发过程中，遇到的各类问题总结，包括JAVA语言，Spring，Spring mvc，ibatis框架等使用过程中遇到的一些常见的，或者不常见的问题。分条列举，附有问题详情以及解决方案。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;1java定义的boolen数据类型的getset函数定义为iseditable&quot;&gt;1.java定义的boolen数据类型的get，set函数（定义为isEditable）：&lt;/h3&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//是否可以编辑&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEditable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isEditable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;现象&lt;/strong&gt;：IDEA自动生成的boolean类型与我们的预期有一定的差异，属性isEditable的getter访问器是isEditable(), 而不是getIsEditable()；setter访问器是setEditable(),而不是setIsEditable()。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：由于属性名isEditable的is没有去掉， 以致java bean类违背了java bean 的命名规范。
&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaBean 的属性名和getter/setter存取方法规则小结：&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;对于常规属性propertyName ， 属性名称的第一个单词小写且字母个数大于1，第二个单词首字母大写。对应的getter/setter方法名为：get/set + PropertyName()， 即属性名称的第一个单词的首字母改成大写，前面再加上”get”或”set”前缀。&lt;/li&gt;
    &lt;li&gt;对于布尔类型propertyName,可以按常规属性的规则编写getter/setter方法外， getter方法可以使用 is + PropertyName()的形式来代替。&lt;/li&gt;
    &lt;li&gt;对于非常规属性pName，属性名称的第一个单词小写且字母个数等于1，第二个单词首字母大写,分一下三种情况：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.&lt;/code&gt;对应的getter/setter方法名可以为：get/set + PName()， 即第一个单词的首字母为改为大写，前面再加上”get”或”set”前缀。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2.&lt;/code&gt;对应的getter/setter方法名也可以为：get/set + pName()， 即属性名称不变，第一个单词的首字母任然为小写，前面再加上”get”或”set”前缀。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3.&lt;/code&gt;对于非常规属性PName， 属性名称的前两个字母都是大写  。即连续两个大写字母开头的属性名。对应的getter/setter方法名为： get/set+PName()&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4.&lt;/code&gt;对于非常规属性&lt;Property&gt;或&lt;PropertyName&gt;， 属性名称第一个字母大写 。网上有帖子说这是不符合JSR规范的，会报 &quot;属性找不到&quot; 的错误。&lt;/PropertyName&gt;&lt;/Property&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：
&lt;strong&gt;1. javabean属性命名尽量使用常规的驼峰式命名规则&lt;/strong&gt;
&lt;strong&gt;2. 属性名第一个单词尽量避免使用一个字母：如eBook， eMail&lt;/strong&gt;
&lt;strong&gt;3. boolean属性名避免使用 “is” 开头的名称&lt;/strong&gt;
&lt;strong&gt;4. 随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JAVA：抽象类VS接口</title>
   <link href="/java/2016/02/21/JAVA-%E6%8A%BD%E8%B1%A1%E7%B1%BBVS%E6%8E%A5%E5%8F%A3.html"/>
   <updated>2016-02-21T00:00:00+08:00</updated>
   <id>/java/2016/02/21/JAVA：抽象类VS接口</id>
   <content type="html">&lt;p&gt;JAVA中抽象类和接口的区别比较，以及它们各自的用途。&lt;/p&gt;

&lt;!--more--&gt;
&lt;h3 id=&quot;1java抽象类&quot;&gt;1.JAVA抽象类:&lt;/h3&gt;
&lt;p&gt;抽象类除了不能实例化以外，跟普通类没有任何区别。在《JAVA编程思想》一书中，将抽象类定义为“包含抽象方法的类”。&lt;/p&gt;

&lt;h3 id=&quot;2java接口&quot;&gt;2.JAVA接口:&lt;/h3&gt;
&lt;p&gt;接口，英文称作interface，是对事物最高层次的抽象，用来供别人调用的方法或者函数。&lt;/p&gt;

&lt;h2 id=&quot;java抽象类和接口的主要区别如下图&quot;&gt;JAVA抽象类和接口的主要区别如下图:&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://sunxiaobiu.github.io/img/20160221P1.jpg&quot; alt=&quot;cmd-markdown-logo&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;什么时候使用抽象类和接口&quot;&gt;什么时候使用抽象类和接口&lt;/h3&gt;
&lt;p&gt;首先，我们要先弄清楚抽象类和接口之间的关系：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;类对事物的抽象，定义了事物的属性和行为。&lt;/li&gt;
    &lt;li&gt;抽象类是不完全的类，具有抽象方法。&lt;/li&gt;
    &lt;li&gt;接口则比类的抽象层次更高。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，我们可以这样理解它们之间的关系：&lt;strong&gt;类是对事物的抽象，抽象类是对类的抽象，接口是对抽象类的抽象&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在设计类的时候，首先考虑用接口抽象出类的特性，当你发现某些方法可以复用的时候，可以使用抽象类来复用代码。简单说，&lt;strong&gt;接口用于抽象事物的特性，抽象类用于代码复用。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Happy New Year</title>
   <link href="/2016/02/06/Happy-New-Year.html"/>
   <updated>2016-02-06T00:00:00+08:00</updated>
   <id>/2016/02/06/Happy-New-Year</id>
   <content type="html">&lt;div style=&quot;margin:20px 0 0 20px&quot;&gt;


&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;input type=&quot;button&quot; value=&quot;test&quot; /&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>在 Cygwin 上编译 Contiki</title>
   <link href="/embedded/2015/10/26/contiki-cygwin.html"/>
   <updated>2015-10-26T00:00:00+08:00</updated>
   <id>/embedded/2015/10/26/contiki-cygwin</id>
   <content type="html">&lt;p&gt;由于使用 Contiki 需要 Linux 环境，切换来切换去很麻烦，幸好 Windows 下面有 Unix 模拟环境软件，Cygwin。本文主要介绍 8051 核的 Contiki 编译，它的编译需要编译器 SDCC，所以本文介绍 SDCC 的编译。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;官方 8051 核的编译文档请参考 &lt;a href=&quot;https://github.com/contiki-os/contiki/wiki/8051-Requirements&quot;&gt;8051 Requirements&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：官方的 win32 版的 SDCC 并不适用。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;依赖&quot;&gt;依赖&lt;/h2&gt;

&lt;p&gt;必须确定安装以下依赖包，可以从 Cygwin 源中直接找到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;gcc&lt;/li&gt;
    &lt;li&gt;flex&lt;/li&gt;
    &lt;li&gt;bison&lt;/li&gt;
    &lt;li&gt;libboost-graph-dev&lt;/li&gt;
    &lt;li&gt;python&lt;/li&gt;
    &lt;li&gt;make&lt;/li&gt;
    &lt;li&gt;texinfo&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;此外，还需要安装一个工具，&lt;a href=&quot;http://srecord.sourceforge.net/&quot;&gt;srecord&lt;/a&gt;，下载 Win32 版本后，直接放于&lt;code class=&quot;highlighter-rouge&quot;&gt;cygwin/bin/&lt;/code&gt;目录下即可。&lt;/p&gt;

&lt;h2 id=&quot;编译-sdcc&quot;&gt;编译 SDCC&lt;/h2&gt;

&lt;h3 id=&quot;sdcc-源码下载&quot;&gt;SDCC 源码下载&lt;/h3&gt;

&lt;p&gt;直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;svn&lt;/code&gt;下载即可，本文版本为&lt;strong&gt;9377&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;svn co svn://svn.code.sf.net/p/sdcc/code/trunk/sdcc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sdcc-源码修改&quot;&gt;SDCC 源码修改&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;device/lib/incl.mk&lt;/code&gt;，找到：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;MODELS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; small medium large
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改成&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;MODELS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; small large huge
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;编译&lt;code class=&quot;highlighter-rouge&quot;&gt;device/lib/Makefile.in&lt;/code&gt;，找到：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;TARGETS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; models small-mcs51-stack-auto
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改成：&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;TARGETS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; models model-mcs51-stack-auto
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;p&gt;进行配置：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --disable-gbz80-port --disable-z80-port --disable-ds390-port --disable-ds400-port --disable-pic14-port --disable-pic16-port --disable-hc08-port --disable-r2k-port --disable-z180-port --disable-sdcdb --disable-ucsim
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译并安装：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;试用&quot;&gt;试用&lt;/h2&gt;

&lt;p&gt;在 Contiki 的&lt;code class=&quot;highlighter-rouge&quot;&gt;example/hello-world&lt;/code&gt;目录下运行：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make &lt;span class=&quot;nv&quot;&gt;TARGET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cc2530dk all
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;便可以生成&lt;code class=&quot;highlighter-rouge&quot;&gt;hello-world.hex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用 SmartRF Flash 工具便可以下载。&lt;/p&gt;

&lt;h2 id=&quot;关于编译-cc-tool&quot;&gt;关于编译 cc-tool&lt;/h2&gt;

&lt;p&gt;还是别折腾了，因为 cygwin 下，libusb 不支持。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Editor 使用入门</title>
   <link href="/daily/2015/10/11/jekyll-editor-tutorial.html"/>
   <updated>2015-10-11T00:00:00+08:00</updated>
   <id>/daily/2015/10/11/jekyll-editor-tutorial</id>
   <content type="html">&lt;p&gt;Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;yourname&amp;gt;.github.io&lt;/code&gt;仓库读取&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下的博客列表，并可以读取、创建、修改博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;项目&quot;&gt;项目&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Github&lt;/strong&gt;：https://github.com/Simpleyyt/jekyll-editor.git&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Chrome 商店&lt;/strong&gt;：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;主要功能&quot;&gt;主要功能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;获取博文列表，发布、更新、修改博文&lt;/li&gt;
  &lt;li&gt;博文自动保存到本地&lt;/li&gt;
  &lt;li&gt;强大的 Markdown 编辑器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用说明&quot;&gt;使用说明&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/10214115.jpg&quot; alt=&quot;Jekyll Editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左上角为编辑器的常用工具，包含&lt;code class=&quot;highlighter-rouge&quot;&gt;emoji&lt;/code&gt;表情。右上角的工具依次为登录、全窗口预览、新博文、博文列表、元数据、提交博文，帮助、关于。&lt;/p&gt;

&lt;p&gt;首次使用时，必须先进行登录，也就是与 github 相连。&lt;/p&gt;

&lt;h3 id=&quot;博文列表&quot;&gt;博文列表&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/12709365.jpg&quot; alt=&quot;博文列表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;博文列表会自动获取&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;yourname.github.io&lt;/code&gt;仓库读取&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;格式的文件，即为博文。&lt;/p&gt;

&lt;h3 id=&quot;元数据&quot;&gt;元数据&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/85340312.jpg&quot; alt=&quot;元数据&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即博文的 yaml 格式数据，博文将会以文件名&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;的格式更新。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：当“发布”打勾时，才会真正地发布。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;已知-bug&quot;&gt;已知 Bug&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在获取博文列表时，可能会由于多方面原因卡死&lt;/li&gt;
  &lt;li&gt;预览窗口的滚动条有时会出现问题&lt;/li&gt;
  &lt;li&gt;发布时可能会卡死&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Editor 应用上线</title>
   <link href="/daily/2015/10/11/jekyll-editor-online.html"/>
   <updated>2015-10-11T00:00:00+08:00</updated>
   <id>/daily/2015/10/11/jekyll-editor-online</id>
   <content type="html">&lt;p&gt;Jekyll Editor 的 Chrome App 版本终于发布，具体地址为：&lt;a href=&quot;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme?hl=zh-CN&quot;&gt;Jekyll Editor&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;为了发布这个应用我真是费了好多心思，因为本人并没有 VISA 卡，也没有信用卡。我想到了一个神奇的网站，不是58，而是淘宝，搜了好久之后，发现有一种叫 VISA 虚拟卡，但是好像不能用，可能会被禁:flushed:。&lt;/p&gt;

&lt;p&gt;当然，还有一种是在线帮忙开，费用非常贵，要200多块，我还是咬咬牙就拍了:sob:。说多了都是泪，哎。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chrome App 地址为：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme?hl=zh-CN&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>写 Jekyll 博客工具</title>
   <link href="/daily/2015/10/09/tool-for-jekyll-blog.html"/>
   <updated>2015-10-09T00:00:00+08:00</updated>
   <id>/daily/2015/10/09/tool-for-jekyll-blog</id>
   <content type="html">&lt;p&gt;上次说要写一个类似 stackeditor 的东西来写 Jekyll 博客，终于写好了。这将是第一篇用该工具写的博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;详细的说明将会在发布之后再说:smiley:，它是 Chrome App，基于 Editor.md 的一个应用，挺不错的，该有的都有，就是有时候有会 Bug，:disappointed_relieved:。但是没事，我以后会慢慢改进。&lt;/p&gt;

&lt;p&gt;我已经把代码 push 到 github 上去了，项目地址：&lt;a href=&quot;https://github.com/Simpleyyt/jekyll-editor.git&quot;&gt;https://github.com/Simpleyyt/jekyll-editor.git&lt;/a&gt;，写得有点乱，以后再慢慢重构。还有一个重要的问题，我没有 chrome 开发者账号:frowning:，好惨。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-9/34912413.jpg&quot; alt=&quot;Jekyll Editor 截图&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>TCP 之保活计时器</title>
   <link href="/network/2015/09/23/tcp-keepalive-timer.html"/>
   <updated>2015-09-23T00:00:00+08:00</updated>
   <id>/network/2015/09/23/tcp-keepalive-timer</id>
   <content type="html">&lt;p&gt;保活计时器并不是 TCP 规范中的一部分，是一个有争论的功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户机有如下状态：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;客户机仍正常运行，回复响应。服务器在两小时以后将保活定时器复位。&lt;/li&gt;
    &lt;li&gt;客户机已崩溃，TCP 都没有响应，75秒后超时。服务器总共发10个这样的探查，每个间隔75秒。&lt;/li&gt;
    &lt;li&gt;客户机已重新启动，客户机回复 RST。&lt;/li&gt;
    &lt;li&gt;客户机正常运行，但是服务不可到达，与状态2相同。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>字节对齐</title>
   <link href="/program/2015/09/23/data-structure-alignmen.html"/>
   <updated>2015-09-23T00:00:00+08:00</updated>
   <id>/program/2015/09/23/data-structure-alignmen</id>
   <content type="html">&lt;p&gt;Linux 沿用的对齐策略是，2字节数据类型（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;）的地址是2的倍数，而较大的数据类型（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;int*&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;）的地址必须是4的倍数。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Windows 要求任何 K 字节基本对象的址址必须是 K 的倍数，K = 2, 4 或者 8。特别的，它要求一个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;类型数据的地址应该是8的倍数。&lt;/p&gt;

&lt;h2 id=&quot;对齐准则&quot;&gt;对齐准则&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;四个重要的基本概念：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。&lt;/li&gt;
    &lt;li&gt;结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。&lt;/li&gt;
    &lt;li&gt;指定对齐值：#pragma pack (value)时的指定对齐值value。&lt;/li&gt;
    &lt;li&gt;数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，有效对齐值&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;是最终用来决定数据存放地址方式的值。有效对齐&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;表示&lt;strong&gt;“对齐在&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;上”&lt;/strong&gt;，即该数据的&lt;strong&gt;“存放起始地址 % N = 0”&lt;/strong&gt;。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(strcut A)&lt;/code&gt;值为8；&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(struct B)&lt;/code&gt;的值却是12。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#pragma pack(2)  //指定按2字节对齐
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma pack()   //取消指定对齐，恢复缺省对齐
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(struct C) = 8&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;栈内存对齐&quot;&gt;栈内存对齐&lt;/h2&gt;

&lt;p&gt;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。（并未考证64位）&lt;/p&gt;

&lt;h2 id=&quot;位域对齐&quot;&gt;位域对齐&lt;/h2&gt;

&lt;p&gt;位域成员不能单独被取&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;值。下面主要讨论含有位域的结构体的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;C99 规定&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其对齐规则大致为：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和小于类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；&lt;/li&gt;
    &lt;li&gt;如果相邻位域字段的类型相同，但其位宽之和大于类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；&lt;/li&gt;
    &lt;li&gt;如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 和 GCC 采取压缩方式；&lt;/li&gt;
    &lt;li&gt;如果位域字段之间穿插着非位域字段，则不进行压缩；&lt;/li&gt;
    &lt;li&gt;整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例3：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;位域类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;，第1个字节仅能容纳下&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;element2&lt;/code&gt;，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;element2&lt;/code&gt;被压缩到第1个字节中，而&lt;code class=&quot;highlighter-rouge&quot;&gt;element3&lt;/code&gt;只能从下一个字节开始。因此&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(BitField)&lt;/code&gt;的结果为2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例4：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StructBitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element4&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element5&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stelement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//在含位域的结构或联合中也可同时说明普通成员
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;位域中最宽类型&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;的字节数为4，因此结构体按4字节对齐，在 VC6 中其&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;为16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例5：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;分配3位，接着跳过余下的4位到下一个存储单元，然后给成员&lt;code class=&quot;highlighter-rouge&quot;&gt;element3&lt;/code&gt;分配5位。故上面的结构体大小为2。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文参考：&lt;a href=&quot;http://www.cnblogs.com/clover-toeic/p/3853132.html&quot;&gt;http://www.cnblogs.com/clover-toeic/p/3853132.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>位域的大小端问题</title>
   <link href="/program/2015/09/23/bit-endian-little-endian-bit-field.html"/>
   <updated>2015-09-23T00:00:00+08:00</updated>
   <id>/program/2015/09/23/bit-endian-little-endian-bit-field</id>
   <content type="html">&lt;p&gt;有如下位域结构体：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;小端：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在寄存器中分布如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 A3 A2 A1 A0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在内存中存放格式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXXXX0020: B3 B2 B1 B0 A3 A2 A1 A0
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: C3 C2 C1 C0 B15 B14 B13 B12
0xXXXX0023: C11 C10 C9 C8 C7 C6 C5 C4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;大端：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在寄存器中分布如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A3 A2 A1 A0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在内存中存放如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXXXX0020: A3 A2 A1 A0 B15 B14 B13
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: B3 B2 B1 B0 C11 C10 C9 C8
0xXXXX0023: C7 C6 C5 C4 C3 C2 C1 C0
C11 C10 C9 C8 C7 C6 C5 C4  B15 B14 B13 B12 C3 C2 C1 C0  B11 B10 B9 B8 B7 B6 B5 B4  A3 A2 A1 A0 B3 B2 B1 B0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;本文转自：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_6f611c300102uznw.html&quot;&gt;http://blog.sina.com.cn/s/blog_6f611c300102uznw.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>TCP 和 UDP 的区别</title>
   <link href="/network/2015/09/22/difference-between-tcp-vs-udp-protocol.html"/>
   <updated>2015-09-22T00:00:00+08:00</updated>
   <id>/network/2015/09/22/difference-between-tcp-vs-udp-protocol</id>
   <content type="html">&lt;ul&gt;
  &lt;li&gt;TCP(Transmission Control Protocol)：传输控制协议&lt;/li&gt;
  &lt;li&gt;UDP(User Datagram Protocol)：用户数据报协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要从连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等8个方面来讲。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;1. TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. TCP可靠，UDP不可靠；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP丢包会自动重传，UDP不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. TCP有序，UDP无序；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4. TCP无界，UDP有界；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP通过字节流传输，UDP中每一个包都是单独的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5. TCP有流量控制（拥塞控制），UDP没有；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要靠三次握手实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6. TCP传输慢，UDP传输快；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7. TCP是重量级的，UDP是轻量级的；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8. TCP的头部比UDP大；TCP Packet Format Diagram UDP Packet format&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。&lt;/li&gt;
    &lt;li&gt;TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。&lt;/li&gt;
    &lt;li&gt;TCP无界有拥塞控制，TCP有界无拥塞控制。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。&lt;/li&gt;
    &lt;li&gt;基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html&quot;&gt;http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C++对象模型之复制构造函数</title>
   <link href="/program/2015/09/22/cpp-object-model-copy-constructor.html"/>
   <updated>2015-09-22T00:00:00+08:00</updated>
   <id>/program/2015/09/22/cpp-object-model-copy-constructor</id>
   <content type="html">&lt;p&gt;&lt;em&gt;“如果一个 class 未定义出 copy constructor，编译器就自动为它产生出一个”&lt;/em&gt; 这句话是不对的，当 class 展现 &lt;strong&gt;bitwise copy semanics&lt;/strong&gt; 时，编译器才会产生出来。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果一个 class 没有提供 explicit copy constructor，把每一个内建的或派生的 data member 的值，从某个 object 拷贝一份到另一个 object 身上，递归方式施行 &lt;strong&gt;memberwise initialization&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ... 没有 explicit copy constructor
&lt;/span&gt;    &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有如下调用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;book&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则会施行 memberwise initialization：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果一个 String object 被声明为另一个 class 的 member，那么进行 memberwise initialization 时，会递归实施。&lt;/p&gt;

&lt;p&gt;什么时候不展现出 bitwise copy semantics，也就是合成 copy constructor 呢，有4种情况：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当 member object 存在 copy constructor。&lt;/li&gt;
    &lt;li&gt;当 base class 存在 copy constructor。&lt;/li&gt;
    &lt;li&gt;当 class 声明了 virtual functions 时。&lt;/li&gt;
    &lt;li&gt;当继承链中有 virtual base class 时。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面两种情况，在此不做讨论。&lt;/p&gt;

&lt;h2 id=&quot;class-声明了-virtual-functions&quot;&gt;class 声明了 virtual functions&lt;/h2&gt;

&lt;p&gt;这种情况下，可能需要重新设定 Virtual Table 的指针。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有如下使用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;winnie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;winnie&lt;/code&gt;会靠 bitwise copy semantics 完成，&lt;code class=&quot;highlighter-rouge&quot;&gt;winnie&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;yogi&lt;/code&gt;都指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Bear class&lt;/code&gt;的 virual table。&lt;/p&gt;

&lt;p&gt;如果是如下使用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;franny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 会发生切割行为
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;franny&lt;/code&gt;的 vptr 不可以被设定指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Bear class&lt;/code&gt;的 virtual table，所以需要重新设定。&lt;/p&gt;

&lt;h2 id=&quot;virtual-base-class-的-subobject&quot;&gt;Virtual Base Class 的 Subobject&lt;/h2&gt;

&lt;p&gt;derived class object 的 virtual base class subobject 位置必须维护，bitwise copy semantics 可能会存坏这个位置。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Raccon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedPanda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是以下调用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rocky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_critter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rocky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么 bitwise copy 就可以了。&lt;/p&gt;

&lt;p&gt;如果是：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_critter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;litter_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候编译器必须安插代码以设定 virtual base class offset 的初值。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>写 Jekyll 博客的正确姿势</title>
   <link href="/jekyll/2015/09/21/tools-for-jekyll.html"/>
   <updated>2015-09-21T00:00:00+08:00</updated>
   <id>/jekyll/2015/09/21/tools-for-jekyll</id>
   <content type="html">&lt;p&gt;用 Jekyll 写博客有个麻烦的地方，就是你可能需要把博客&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;下来，修改完成&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;后，再&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;上 GitHub；或者使用 GitHub 的在线编辑器编辑，无论哪种都非常麻烦。幸好找到了几个第三方的写博客和图床工具。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;写博客工具&quot;&gt;写博客工具&lt;/h2&gt;

&lt;p&gt;有两个工具，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyller&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;prose.io&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;jekyller&quot;&gt;Jekyller&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyller&lt;/code&gt;是 Chrome 上的应用，它可以管理你的所有博客，实时&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;渲染。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/21644919.jpg&quot; alt=&quot;Jekyller&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是它的 UI 比较难看，而且对&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;的支持也不是很好。&lt;/p&gt;

&lt;h3 id=&quot;proseio&quot;&gt;Prose.io&lt;/h3&gt;

&lt;p&gt;非常好的一个工具，它的编辑器非常强大，可以上传图片、文件等，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;文件中配置&lt;code class=&quot;highlighter-rouge&quot;&gt;prose.io&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/82332870.jpg&quot; alt=&quot;Prose.io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缺点就是不支持实时预览，而且也不会自己保存。&lt;/p&gt;

&lt;h2 id=&quot;图床&quot;&gt;图床&lt;/h2&gt;

&lt;p&gt;图床的话强烈推荐&lt;strong&gt;七牛&lt;/strong&gt;，其缺点就是操作不人性化，但是 chrome 上面有好多相关的插件解决这个问题，比如&lt;a href=&quot;http://yotuku.cn/&quot;&gt;极简图床&lt;/a&gt; 便是基于七牛的图床网站。&lt;/p&gt;

&lt;h2 id=&quot;图表工具&quot;&gt;图表工具&lt;/h2&gt;

&lt;p&gt;写博客难免会需要用画一些图表，有两类图表，一类是 &lt;a href=&quot;http://yuml.me/diagram/scruffy/class/draw&quot;&gt;yUML&lt;/a&gt;、&lt;a href=&quot;http://plantuml.com/&quot;&gt;plantUML&lt;/a&gt;, 另一类是 &lt;a href=&quot;http://draw.io&quot;&gt;draw.io&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;yuml-和-plantuml&quot;&gt;yUML 和 plantUML&lt;/h3&gt;

&lt;p&gt;这类图表只需要按格式输入代码，便会自动产生图表，生成图片链接，省去了上传到图床，后期也可以修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/46889912.jpg&quot; alt=&quot;yUML&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/34152859.jpg&quot; alt=&quot;plantUML&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;drawio&quot;&gt;draw.io&lt;/h3&gt;

&lt;p&gt;这个是在线手动绘图的工具，chrome 应用商店里面也下载得到离线应用，绘图完成之后需要上传到图床中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/68984484.jpg&quot; alt=&quot;draw.io&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
